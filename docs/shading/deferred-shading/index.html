<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-shading/deferred-shading/index" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.1">
<title data-rh="true">3.2 延迟着色 | TheGIBook</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://thegibook.com/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://thegibook.com/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://thegibook.com/docs/shading/deferred-shading/"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="3.2 延迟着色 | TheGIBook"><meta data-rh="true" name="description" content="传统的渲染管线使用一个着色器进行整个渲染工作，这个渲染过程其实包括两部分的内容：通过深度测试找出场景中的所有可视点，以及对每个表面点进行着色。利用光栅化技术进行渲染的过程中深度测试是不可避免的（它是图形处理器存在的最重要理由之一），而过度绘制的计算发生于表面着色计算过程，如果我们能够将着色过程和深度测试过程分开，将着色计算延迟到深度测试之后，我们就能避免因被深度测试丢弃片元产生的不必要的着色计算，这就是延迟着色（deferred shading）技术的原理，与之相对应，我们将传统用于深度测试以确定可视区域的渲染管线称为前向着色（前向着色的概念其实并不准确，因为第一阶段只是进行深度测试以确定场景中的可视区域，并不涉及表面着色的计算，这里仅仅是为了区分延迟着色中的不同阶段。）（forward shading）。"><meta data-rh="true" property="og:description" content="传统的渲染管线使用一个着色器进行整个渲染工作，这个渲染过程其实包括两部分的内容：通过深度测试找出场景中的所有可视点，以及对每个表面点进行着色。利用光栅化技术进行渲染的过程中深度测试是不可避免的（它是图形处理器存在的最重要理由之一），而过度绘制的计算发生于表面着色计算过程，如果我们能够将着色过程和深度测试过程分开，将着色计算延迟到深度测试之后，我们就能避免因被深度测试丢弃片元产生的不必要的着色计算，这就是延迟着色（deferred shading）技术的原理，与之相对应，我们将传统用于深度测试以确定可视区域的渲染管线称为前向着色（前向着色的概念其实并不准确，因为第一阶段只是进行深度测试以确定场景中的可视区域，并不涉及表面着色的计算，这里仅仅是为了区分延迟着色中的不同阶段。）（forward shading）。"><link data-rh="true" rel="icon" href="/img/thegibook.jpg"><link data-rh="true" rel="canonical" href="https://thegibook.com/docs/shading/deferred-shading/"><link data-rh="true" rel="alternate" href="https://thegibook.com/docs/shading/deferred-shading/" hreflang="en"><link data-rh="true" rel="alternate" href="https://thegibook.com/docs/shading/deferred-shading/" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="TheGIBook RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="TheGIBook Atom Feed">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.f107caf2.css">
<script src="/assets/js/runtime~main.9cae4c1c.js" defer="defer"></script>
<script src="/assets/js/main.34cf7fb1.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/thegibook.jpg" alt="全局光照技术：从离线到实时渲染" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/thegibook.jpg" alt="全局光照技术：从离线到实时渲染" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">TheGIBook</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/preface">阅读图书</a><a class="navbar__item navbar__link" href="/blog">博客</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/ElvisQin/thegibook" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/preface">前 言</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/introduction/">1 光与表面的交互</a><button aria-label="Expand sidebar category &#x27;1 光与表面的交互&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/hardware/">2 并行处理器架构</a><button aria-label="Expand sidebar category &#x27;2 并行处理器架构&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/shading/">3 着色管线</a><button aria-label="Collapse sidebar category &#x27;3 着色管线&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/shading/shading-basis/">3.1 着色技术基础</a><button aria-label="Expand sidebar category &#x27;3.1 着色技术基础&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible menu__list-item-collapsible--active"><a class="menu__link menu__link--sublist menu__link--active" aria-current="page" aria-expanded="true" tabindex="0" href="/docs/shading/deferred-shading/">3.2 延迟着色</a><button aria-label="Collapse sidebar category &#x27;3.2 延迟着色&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/shading/deferred-shading/deferred-lighting">3.2.1 延迟光照计算</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/shading/light-assignment/">3.3 光源分配</a><button aria-label="Expand sidebar category &#x27;3.3 光源分配&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/shading/shader-mangement">3.4 着色器管理</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/shading/anti-aliasing/">3.5 延迟着色中的反走样技术</a><button aria-label="Expand sidebar category &#x27;3.5 延迟着色中的反走样技术&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/monte-carlo/">4 蒙特卡洛方法</a><button aria-label="Expand sidebar category &#x27;4 蒙特卡洛方法&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/path-tracing/">5 路径追踪技术</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/photon-mapping/">6 光子映射</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/mlt/">7 梅特波利斯光照传输</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/radiosity/">8 辐射度方法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/instant-radiosity/">9 即时辐射度方法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/precomputed-radiance-transfer/">10 基于预计算的全局光照技术</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/voxel-based-global-illumination/">11 基于体素的全局光照技术</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/distance-field-gi/">12 基于距离场的全局光照技术</a></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/shading/"><span itemprop="name">3 着色管线</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">3.2 延迟着色</span><meta itemprop="position" content="2"></li></ul></nav><div class="theme-doc-markdown markdown"><header><h1>3.2 延迟着色</h1></header><p>传统的渲染管线使用一个着色器进行整个渲染工作，这个渲染过程其实包括两部分的内容：通过深度测试找出场景中的所有可视点，以及对每个表面点进行着色。利用光栅化技术进行渲染的过程中深度测试是不可避免的（它是图形处理器存在的最重要理由之一），而过度绘制的计算发生于表面着色计算过程，如果我们能够将着色过程和深度测试过程分开，将着色计算延迟到深度测试之后，我们就能避免因被深度测试丢弃片元产生的不必要的着色计算，这就是延迟着色（deferred shading）技术的原理，与之相对应，我们将传统用于深度测试以确定可视区域的渲染管线称为前向着色（前向着色的概念其实并不准确，因为第一阶段只是进行深度测试以确定场景中的可视区域，并不涉及表面着色的计算，这里仅仅是为了区分延迟着色中的不同阶段。）（forward shading）。</p>
<p>分析第3.1节式（2），要想实现着色计算和深度测试的分离，我们唯一需要做的是对每个深度测试通过的像素使用额外的方式记录下所有这些着色参数，然后使用一个单独的渲染通道来仅对这些可视的像素点进行着色计算。这些包含着色参数的缓存对象称为几何缓存（Geometry buffer，G-buffer），这些着色参数可以使用现代图形处理器接口提供的MRT特性进行存储。</p>
<div><div align="center" id="f:shade-deferred-pipeline"><img src="/img/figures/shade/deferred-pipeline.svg" width="100%"></div><p align="left"><b>图（<!-- -->1<!-- -->）：</b>延迟着色的过程，它在传统的渲染管线基础上，将着色过程和深度测试过程分离，在前向着色阶段仅将着色参数写入到G-buffer中，然后使用一个额外的延迟着色阶段来对像素进行着色计算</p></div>
<p>延迟着色的过程如图（1）所示，它可以简述如下：</p>
<ol>
<li>绘制场景中所有的不透明几何体，并将每个片元对应的法线矢量，漫反射折射率，以及高光扩散系数等存储到G-buffer中，如本书后面图（2）所示。此过程涉及在片元着色器中输出多个颜色值，因此需要用到图形处理器接口中的MRT特性。此过程称为前向着色阶段。</li>
<li>分别计算每个光源对可见表面点的影响。这通过分别绘制包围每个光源影响范围的几何体来实现，此时我们应该关闭深度测试，因为我们只需要找出该光源影响的屏幕上的区域，同时每个光源包围几何体有两个面，我们应该根据情况绘制光源包围几何体的其中一面，例如当摄像机位于光源包围几何体内部时，我们应该绘制该几何体的背面，否则只需要绘制正面。对于一些没有体积的光源如直线光源，以及光源影响范围同时包括视锥体近平面和远平面时，我们直接绘制一个2D的包括全屏的平面。在着色器中，前向着色阶段输出的G-buffer将作为纹理数据被读入，G-buffer中的深度值用来计算像素的3D位置，以此用来计算光源的距离递减函数以及查询阴影贴图。最后该光源对每个像素点的颜色计算结果被写入到一个累积缓存（accumulate buffer）。此过程称为延迟着色阶段。</li>
<li>按传统的渲染管线绘制所有半透明的物体。</li>
</ol>
<div><div align="center" id="f:shade-g-buffer"><img src="/img/figures/shade/g-buffer-depth.png" alt="深度+模板" width="24%"><img src="/img/figures/shade/g-buffer-spec.png" alt="高光扩展系数" width="24%"><img src="/img/figures/shade/g-buffer-diffuse.png" alt="漫反射率" width="24%"><img src="/img/figures/shade/g-buffer-normal.png" alt="表面法线" width="24%"></div><p align="left"><b>图（<!-- -->2<!-- -->）：</b>一个基本的几何缓存包含深度，漫反射率，表面法线矢量，以及高光扩展系数几个基本的第3.1节式（2）中的着色参数，这些着色参数可以被延迟着色（或其他后处理）阶段用于着色计算（图片来自Dice）</p></div>
<p>延迟着色技术解决了传统渲染管线中的过度绘制的问题，这是通过牺牲内存占用来实现的，它用一个巨大的几何缓存对象将那些着色参数暂存起来，以便能够在稍后待所有不可见的像素被深度测试剔除之后再进行必要的光照计算，能这样做的原因是深度测试本身和着色计算几乎是完全独立的，所以延迟着色计算的结构几乎和传统渲染管线是一致的，并且延迟着色使渲染性能不再与场景的复杂度像耦合（尤其延迟着色支持数量巨大的光源），能够保证稳定的帧率，稳定的帧率是实时渲染领域中的一个重要的衡量指标。</p>
<p>虽然有上述这些优点，并且从渲染结果上看延迟渲染和传统渲染管线的结果是一致的（因为它并没有对第3.1节式（2）作任何修改），但是延迟渲染还是带来了一些新的问题，其中一些主要的问题包括：</p>
<ul>
<li>不支持半透明物体。一个包含半透明表面的像素点的颜色值是两个（或多个）表面点颜色值混合的结果，由于G-buffer只保存每个像素点的一个表面点的值，所以它不能支持半透明物体，在延迟渲染中我们必须对半透明物体单独采用传统的渲染管线来处理。</li>
<li>巨大的帧缓存存储占用。通常一个G-buffer中每个像素可以占用多达128bits甚至以上的内存占用，当使用多重采样时更是会占用巨大的内存（我们将在第（3.5）节讨论延迟着色中多重采样的问题）；此外，为了保证多个光源累加结果的精确性，颜色累积缓存还必须使用更高精度的缓存对象。</li>
<li>对屏幕区域的像素点（而不是根据每个物体自身的类型）进行着色计算，这使得我们很难针对每种物体使用自定义的着色器，因为各种类型的物体被混在一个  屏幕区域，我们必须使用统一的着色器，这使得自定义着色器变得非常困难，我们将在第（3.4）节中讨论延迟着色中的着色器管理。</li>
<li>最后一个问题是内存访问的高带宽占用，这将在本节及接下来的内容中重点介绍。</li>
</ul>
<p>带宽问题是延迟渲染方法带来的新的问题，它带来了一种新的形式的过度绘制，以下是一个传统延迟着色中的着色计算阶段，它对每个光源包围盒形成的几何体绘制一次，然后在其覆盖的屏幕2D区域内对每个像素执行着色计算：</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">for each light</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	for each covered pixel</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		read G-buffer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		compute shading</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		read + write frame buffer</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>从以上的伪代码中我们看到，对于每个光源覆盖的每个像素点，着色器都要分别对帧缓存执行：读取--&gt;计算--&gt;写入的操作，如果一个像素点被多个光源所覆盖，这在整个着色计算过程中这个像素点对应的着色数据会被重复读写多次，这就导致一种新的过度绘制。</p>
<div><div align="center" id="f:shade-gpu-trends"><img src="/img/figures/shade/gpu-trends.svg" width="650"></div><p align="left"><b>图（<!-- -->3<!-- -->）：</b>GPU性能发展趋势，其计算能力的提升速度会大大高于带宽的提升速度，这其实对CPU也是一样的，所以应用程序应该充分优化以更紧密地对数据进行利用，而不是频繁重复地读写</p></div>
<p>通过第（2）章的内容可知，处理器对任何寄存器以外的内存读取都会导致延迟，这些延迟包括存储器本身处理数据输入输出的延迟，以及数据由存储器向处理器传输过程中带宽的限制。图（2）是近十几年GPU性能发展的趋势，我们可以看出GPU计算能力提升的速度会大大高于其传输带宽的提升，虽然缓存可以在一定程度上减少带宽导致的延迟，但是它仍然比寄存器要慢得多；同时在GPU中，缓存是基于内核内多个线程共享的，它还必须处理同步的问题。所以在GPU编程中，我们要充分优化内存读写的算法，尽可能地将数据读取到寄存器（回想第（2）章的内容，GPU拥有数量众多的寄存器，将数据读取到本地寄存器，并在单线程内进行足够的计算，然后将最终计算结果写入全局内部是GPU并行计算的基本策略。），对其进行更多计算使用，然后再写入到全局内存中。</p>
<p>针对带宽的问题，我们有两种解决方案：比较好的解决方案是将循环结构中光源的循环放入到双重循环结构的内部，这样针对所有覆盖该表面点的光源只需要对G-buffer 中的数据读写一次，但是这需要额外的工作来找出每个表面点被哪些光源覆盖，即所谓的光源分配（light assignment），这种解决方案正是本章后面第（3.3.1）和（3.3.2）节的内容，这些方法的重点内容就是解决光源分配。</p>
<p>另一种解决方案，则是减少光源循环中读取数据的数量，即进一步将着色计算中的光照计算分离出来，例如后面的延迟光照方法中，G-buffer中只需要32位存储一个法线矢量即可，大大减少了带宽的占用，本节剩下的内容就将讨论这种减少光源循环中对G-buffer数据读取的数量的方案。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/ElvisQin/thegibook/edit/master/website/docs/3-shading/2-deferred-shading/index.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"><span class="theme-last-updated">Last updated<!-- --> on <b><time datetime="2024-01-07T08:22:41.000Z">Jan 7, 2024</time></b> by <b>Chunlin Qin</b></span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/shading/shading-basis/rasterization"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">3.1.1 光栅化技术</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/shading/deferred-shading/deferred-lighting"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">3.2.1 延迟光照计算</div></a></nav></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2018-2024 TheGIBook & 秦春林. All rights reserved.</div></div></div></footer></div>
</body>
</html>